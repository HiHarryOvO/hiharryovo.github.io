---
title: KMP 算法详解
date: 2022-04-21 01:40:00
tags:
- 算法
- 数据结构

mathjax: true
---

最近学习了字符串匹配中非常有名的 KMP 算法（KMP 是 Knuth-Morris-Pratt 的缩写，是发明这个算法的三个人的名字）。KMP 算法是串匹配中的一个重要成果，因为它是第一个线性时间复杂度的串匹配算法。

### 问题简介

串匹配问题要求我们在文本串 T 中寻找满足模式串 P 的部分，例如：

```
T = "今天是晴天，明天是晴天，后天不一定是晴天"
P = "晴天"
```

串匹配问题会有以下几种形式的子问题：

- detection：P 是否出现在 T 中？（P 出现在 T 中，以下均讨论上面的例子）
- location：P 首次在哪里出现？（P 的首次出现位置在下标 3）
- counting：P 共出现几次？（P 出现 3 次）
- enumeration：各出现在哪里？（P 的出现位置下标分别为 3,9,18）

在上述任务中，只要我们能够完成 location 任务，即判断 P 的首次出现位置，就可以很轻松地解决另外几项任务，也就是说，只要我们学会匹配 1 次，那么就学会了匹配多次。因此以下讨论我们主要以解决 location 问题为主。

### 蛮力算法 Brute Force

首先回顾一下蛮力算法。在本问题中，蛮力算法有两种思路，根据具体实现可以分为 固定单一指针 和 双指针同时移动 两种。在这两种解法中，我们都需要两个指针 `i` 和 `j`，各自指向文本串和模式串。

- 1、固定单一指针

固定单一指针的思路非常直白：以文本串中的每个位置为**起点**，与模式串尝试匹配，如果失配则以下一位置为起点，重复这一过程。代码如下：

```python
def find(text, pattern):
    # 蛮力算法 1
    m, n = len(text), len(pattern)
    if m < n:
        return -1
    i = 0
    while i < m:
        j = 0
        while j < n:
            if text[i+j] != pattern[j]:
                break
            j += 1
        if j == n:
            break
        i += 1
    return i if i < m else -1
```

以上代码中，`i` 表示当前文本串中视为匹配起点的位置，`j` 表示当前模式串中匹配到的位置，`i + j` 即是当前文本串中匹配到的位置。我们每次固定 `i`，然后根据匹配完成不断移动 `j`；匹配失败则从 `i+1` 位置重新开始。

对我自己而言，在没有学习 KMP 算法之前，提到字符串匹配的蛮力算法，我一定会想到这一个做法。但其实下面提到的双指针同时移动的解法，更有助于我们后面去理解 KMP 算法的过程。

- 2、双指针同时移动

在这个算法中，我们在匹配过程中同时更新文本串和模式串中的指针，一旦发生失配，根据目前已经匹配的部分将两个指针回退到对应的位置。代码如下：

```python
def find(text, pattern):
    # 蛮力算法 2
    m, n = len(text), len(pattern)
    if m < n:
        return -1
    i, j = 0, 0
    while i < m and j < n:
        if text[i] == pattern[j]:
            i += 1
            j += 1
        else:
            i -= j - 1
            j = 0
    return i - j if i - j + n - 1 < m else -1
```

如果 `i` 位置和 `j` 位置匹配，则 `i` 和 `j` 同时移动。如果失配，`j` 回退到 0，我们根据 `j` 的回退可以计算出 `i` 在 `i-j` 这一起点处无法匹配，因此应当回退到 `i-j` 的下一位置，即 `i-j+1`。

关于返回结果的判断，最后理应返回起点位置在 `i-j`，如果文本串 `i-j` 位置到终点的长度不足 n，那么说明文本串中无法匹配到模式串。

对于上述两种蛮力算法，若 m 和 n 分别表示文本串和模式串的长度，在最坏情况下，每次比对都几乎需要 n 次，同时需要遍历整个文本串，因此时间复杂度为 O(n * m)。一种产生最坏情况的例子如下：

```
T = "AAAAAAAAAAAAAAAAAAAAAAAAAAB"
P = "AAAAB"
```

观察上面的例子，以及分析最坏情况产生的条件——从文本串的每个位置开始比对都几乎需要 n 次，说明文本串中有非常多重复的部分，因此可以推断出字符集 |∑| 的大小对于算法效率也有影响。|∑| 越小，文本串中越可能出现重复部分，最坏情况出现的概率越高。而模式串长度 n 越大，最坏情况的后果也更加严重（m >> n，时间复杂度为 O(m * n)，因此 n 稍微增加即会引入很多计算量）。

### KMP 算法原理

KMP 算法的一个核心思想就是减少匹配过程中的重复比对。具体如何减少重复比对呢？看下面这个例子。

```
T = "CHILLCHILLCHIK"
P = "CHILLCHIA"
```

首先我们会以文本串 T 的第一个字符 "C" 作为起点开始匹配，然后依次匹配 "H"、"I"、"L"、"C"、"H"、"I"，在下一个位置 "L-A" 发生失配。按照两种蛮力算法的思路，接下来会以文本串的第二个字符 "H" 作为起点尝试匹配。

反思这个过程，以 "C" 为起点的匹配在 "L-A" 位置失败后，我们选择以 "H" 为起点。但是，根据之前的匹配信息我们知道，下一个 "C" 在下标 5 的位置，因此在 "L-A" 位置失败后我们应该尝试以下标 5 为起点，而不是以下标 1 位置的 "H" 为起点。下一次匹配的字符应该是文本串 T 的下标 8 的 "L" 和模式串 P 的下标为 3 的 "L"。

也就是说，如果我们的算法“记得”之前匹配过哪些字符，即可跳过一些多余的匹配，直接调整到需要的位置。这个过程中，文本串 T 的指针 i 不发生改变，我们只需要移动模式串 P 的指针 j 即可（注意到这里的流程与蛮力算法 2 非常接近，区别在于蛮力算法需要回退 i，KMP 不用，而蛮力算法 j 回退到 0，KMP 算法中 j 回退到 `next[j]`）。因此我们可以构建一张 next 查询表，`k = next[j]` 表示如果当前位置 `T[i] != P[j]`，即发生失配，接下来应该比较 `T[i]` 和 `P[k]`。

因此我们可以写出 KMP 算法的代码：

```python
def kmp_find(text, pattern):
    m, n = len(text), len(pattern)
    if m < n:
        return -1
    nex = build_next(pattern)  # how to implement this?
    i, j = 0, 0
    while i < m and j < n:
        if j < 0 or text[i] == pattern[j]:
            i += 1
            j += 1
        else:
            j = nex[j]
    return i - j if i - j + n - 1 < m else -1
```

（P.S.: Python 中 next 是内置的用于迭代器的函数，因此我偏好在代码中使用 nex 来指代 next 数组）

从上面的代码中我们可以看到，`i` 和 `j` 匹配时，各自前进一步；一旦发生失配，使用 `i` 和 `nex[j]` 尝试匹配。这就是 KMP 算法的整体流程。

在本节开头的例子中，根据我们对于 next 表的理解，模式串 "CHILLCHIA" 的 next 表应该写成这样：

```
C  H I L L C H I A
-1 0 0 0 0 0 1 2 3
```

代码中 `j < 0` 的部分对应着 next 表中首项 `next[0] = -1` 的位置。如果 T 和 P 在 `P[0]` 的位置失配了，我们需要将 `i` 右移一位，尝试下一位置作为起点。但是我们的代码的主要思路是：`i` 要么和 `j` 同时移动要么不移动。为了方便我们设置 `j = -1`，并让算法在 `j < 0` 的时候将 `i` 和 `j` 同时右移一位。这样达到了 `i` 右移并且 `j` 归位到 0 的效果，并且保证了代码的简洁性。

接下来的问题就是：如何实现构建 next 表的函数？

根据我们之前的描述，next 表用于指示 `P[j]` 处失配时应该替换 `j` 的下标。能够这样操作，是因为模式串的后缀和前缀产生了重复部分。例如 "CHILLCHIA" 中前后两个不同的 "CHI"。因此，从另一种角度来看，`next[j]` 是在 `P[0,j)` 中，最大自匹配的真前缀和真后缀的长度。

我们考虑使用**递推**的思想来计算 next 数组。`next[k+1]` 的取值，即是 `P[0, k+1)`（或者表示为 `P[0,k]`）中最大自匹配的真前缀和真后缀的长度。如果 `P[k] == P[next[k]]`，那么有 `next[k+1] = next[k] + 1`。

如果 `P[k] != P[next[k]]`，那么说明 `next[k]` 长度的前缀（or say 后缀）在 `P[0,k]` 范围内不可行，我们需要接着去看 `P[next[next[k]]]`，也就是一个更短的前缀。如果 `P[next[next[k]]]` 可行，`next[k+1] = next[next[k]] + 1`。如果不可行，则需要继续嵌套调用 next，直到最终查询到 `next[0] = -1`。

结合实际的例子去理解：

```
C  H I L L C H I A
-1 0 0 0 0 0 1 2 3
```

在这个例子中，下标 6 位置的字符为 H，`next[6]` 需要考虑 `P[0:5]`，即 "CHILLC" 的最大自匹配真前缀和真后缀长度，可以看出是 "C"，因此 `next[6] = 1`。对于 `next[7]` 而言，对比 `P[6] = "H"` 和 `P[next[6]] = P[1] = "H"`，二者相等，因此 `next[7] = next[6] + 1`。

我在学习 KMP 算法的时候最开始一直没有理解什么时候需要调用 `next[next[k]]` 去替换 `next[k]`，感觉这个递归调用非常抽象，容易陷入“既然 `P[k]` 和 `P[next[k]]` 不相等，那设置 `next[k+1] = 0` 不就可以了吗”这种思维误区。实际上用具体的例子来说明会更容易理解：

```
C  H I L L C H I A C H I L L C H I L L
-1 0 0 0 0 0 1 2 3 0 1 2 3 4 5 6 7 8 4
```

如果理解了 next 数组的基本原理，除了最后一个字符的所有位置的取值都可以理解。我们先来看倒数第二个字符 "L"，此处匹配到的最长公共前后缀是 "CHILLCHI"，尽管当前位置的 "L" 和 "A" 并不匹配，但是不影响此处 next 的取值。到了最后一个字符 "L"，此时 "CHILLCHIA" 和 "CHILLCHIL" 并不匹配，**但这并不意味着我们要丢弃整个 "CHILLCHIL" 部分，"CHIL" 是一个可行的、更短的最长前后缀**。这也就是为什么我们需要递归去调用 next。

由此可以写出构建 next 数组的代码：

```python
def build_next(text):
    nex = [0] * len(text)
    nex[0] = -1
    t, j = 0, 1
    while j < len(text) - 1:
        if t < 0 or text[j] == text[t]:
            j += 1
            t += 1
            nex[j] = t
        else:
            t = nex[t]
    return nex
```

时间复杂度分析：令 `k = 2*i - j`，在 `kmp_find()` 代码中，每次循环中，如果进入 if 条件内，`i` 和 `j` 同时加 1，`k` 因此加 1；如果进入 else 条件内，`i` 不变，`j` 至少减 1，`k` 因此至少加 1。因此 `k` 是迭代步数的**上界**。

$$
k = 2i - j \le 2(m - 1) - (-1) = 2m - 1 = O(m)
$$

结合构建 next 表需要的时间复杂度为 O(n)，因此可知，KMP 算法时间复杂度为 O(n + m)。

然而，上述算法仍有优化空间：

```
T = "AAABAAAAAAAB"
P = "AAAAAAB"
```

第一次匹配失败于下标 3，即 "B-A" 处。失败后需要用 `next[j]` 替换 j，即用 `P[2]` 替换 `P[3]`，`P[2]` 失败后再用 `P[1]` 替换 `P[2]`，以及用 `P[0]` 替换 `P[1]`，至此才发现全部都不匹配。

这个过程的问题在于：我们每次用模式串 P 中的 "A" 尝试去匹配文本串 T 的 "B" 失败后，下次和 "B" 尝试匹配的仍然是字符 "A"。根据 next 表的定义可知，`next[j]` 用到了 `P[0,j-1]` 的经验知识，却没有用到 `P[j]` 位置的信息。

因此我们对 next 表的构造算法稍加修改，思路为：只有 `P[j] != P[t]` 时才将 t 赋值给 `next[j]`，否则将 `next[t]` 赋值给 `next[j]`。具体代码如下：

```python
def build_next(text):
    nex = [0] * len(text)
    nex[0] = -1
    t, j = 0, 1
    while j < len(text) - 1:
        if t < 0 or text[j] == text[t]:
            j += 1
            t += 1
            nex[j] = t if text[j] != text[t] else nex[t]  # 在此处优化处理
        else:
            t = nex[t]
    return nex
```

### 代码

整合上面的 KMP 算法主部分以及 next 数组构建算法部分，最终代码如下：

```python
# next 数组构建方法
def build_next(text):
    nex = [0] * len(text)
    nex[0] = -1
    t, j = 0, 1
    while j < len(text) - 1:
        if t < 0 or text[j] == text[t]:
            j += 1
            t += 1
            nex[j] = t if text[j] != text[t] else nex[t]
        else:
            t = nex[t]
    return nex

# KMP 算法主代码
def kmp_find(text, pattern):
    m, n = len(text), len(pattern)
    if m < n:
        return -1
    nex = build_next(pattern)  # how to implement this?
    i, j = 0, 0
    while i < m and j < n:
        if j < 0 or text[i] == pattern[j]:
            i += 1
            j += 1
        else:
            j = nex[j]
    return i - j if i - j + n - 1 < m else -1
```

### 总结

KMP 算法的精妙之处在于：抓住文本匹配中“重复匹配”这一关键问题，结合模式串自身结构特点建表，利用过往匹配的经验知识为后续的匹配过程节省计算量。

尽管在面试中 KMP 算法被认为是“超纲考点”，但是作为文本匹配里面的经典算法，通过巧妙的构思将原本 O(n * m) 复杂度的算法优化到 O(n + m)，是非常厉害的事情，也体现了算法设计之美，我个人感觉还是很有必要学习了解一下。

### 参考资料

- [数据结构](https://dsa.cs.tsinghua.edu.cn/~deng/ds/dsacpp/)（C++ 语言版及 MOOC 课程），邓俊辉，清华大学
- [KMP算法](https://en.wikipedia.org/wiki/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm)，维基百科